language specific codegen files will just contain emit_template calls
init_template_context() to initialize the template context 
translate_template_context() to translate the template context by language
framework-level implementation can be done through the template

name-transformations (camelCase/snake_case) will be handled in the template using functions that we can import into jinja2 (to_camel_case, to_snake_case)



template_context: DICTIONARY
{
    paths: <paths>
    schemas: [<schema>]
    base_path: <string>
    _current_tag: <string>
}

paths: DICTIONARY # key is tag
{
    <string>: [<path>]
    default: [<path>]
}

schema: CLASS
{
    name: <string>
    properties: [<property>]
    dependencies: hashset (or [<string>] but hashset is better here imo)
    enums: [<enum>]

    # UNSURE IF THESE ARE USED
    check openapi3 spec guidelines for other possible variables. We don't have to actually use these fields, but good to provide them
}

enum: CLASS
{
    name: <string>
    valid: [<string>]

    # UNSURE IF THESE ARE USED

}

property: CLASS
{
    name: <string>
    type: <string>
    required: <boolean>

    # UNSURE IF THESE ARE USED
    check openapi3 spec guidelines for other possible variables. We don't have to actually use these fields, but good to provide them
}

path: CLASS
{
    tag: <string>
    method: <string>
    function_name: <string>
    200_response_schema: <string>
    response_formats: [<string>]
    request_body_format: [<string>]
    dependencies: hashset (or [<string>] but hashset is better here imo)
    parameters_in: hashset (or [<string>] but hashset is better here imo)
    parameters: [<parameter>]
    responses: [<response>] OR {<number>, <response>}

    # UNSURE IF THESE ARE USED
    summary: <string>
    description: <string>
    externalDocs:
    callbacks:
    deprecated: <boolean>
    security:
    servers:
    extensions:
}

response: CLASS
{
    code: <number>
    formats: [<string>]
    schemas: [<string>]

    # UNSURE IF THESE ARE USED
    description: <string>
    headers:
    extensions:
}

parameter: CLASS
{
    name: <string>
    type: <string>
    required: <boolean>
    in: <string>

    # UNSURE IF THESE ARE USED
    description: <string>
    deprecated: <string>
    allowEmptyValue: <boolean>
    style: <string>
    explode: <boolean>
    example:
    examples:
    extensions:
}

dependencies:
- in 'responses' 'content' 'schema'
- used for determining which files to import

parameters_in:
- go through each parameter and get the 'in' field

request_body:
- if path has no 'requestBody' field, leave as empty array: []
- if 'requestBody' field doesn't specify 'content', set to default: ['application/json', 'application/xml']
- if 'requestBody' field specifies 'content', set to whatever is in the 'content' field

currently not dealing with:
- alternate servers
- security
- references?
